package com.github.r73pls.djl_Project.ndarray;

import ai.djl.ndarray.NDArray;
import ai.djl.ndarray.NDManager;
import ai.djl.ndarray.types.DataType;
import ai.djl.ndarray.types.Shape;

import java.io.IOException;

public class NdArrayLes1 {

    /** создание массива размерностью size
    * NDManager реализует интерфейс автоматического закрытия и управляет жизненными циклами
    * созданных им ndarray. Это необходимо для управления потреблением встроенной памяти,
    * которое Java Garbage Collector не контролирует.
    * Обычно NDManager добавляют в блоки try, чтобы все ndarrays были закрыты вовремя.
    */

    public static NDArray createNdArray(int size){
//        try (NDManager manager =NDManager.newBaseManager()) {
//           return manager.arange(size);
//        }
        NDManager manager =NDManager.newBaseManager();
        return manager.arange(size);
    }

    /**
     * Мы можем получить доступ к форме массива данных (длине вдоль каждой оси),проверив его свойство shape
     */
    public static Shape getNDarrayShape(NDArray array){
   return array.getShape();
}

/**
* Если мы просто хотим узнать общее количество элементов в массиве ndarray,то есть произведение всех элементов shape,
* мы можем проверить его свойство size.x.size();
*/
 public  static long getNdArraySize(NDArray array){
        return array.size();
 }

 /**
* Чтобы изменить форму ndarray без изменения количества элементов или их значений,
* мы можем вызвать функцию reshape. Например, мы можем преобразовать наш ndarray, x,
* из вектора строк с формой (12) в матрицу с формой (3, 4)
* x=x.reshape(3,4)
* ndarray может автоматически вычислять одно измерение, учитывая остальные. Мы используем эту возможность,
* устанавливая значение -1 для измерения, которое мы хотели бы, чтобы ndarray автоматически выводил.
* В нашем случае, вместо вызова x.reshape(3, 4), мы могли бы эквивалентно вызвать x.reshape(-1, 4) или x.reshape(3, -1).
*/
    public static NDArray reshapeNDarray (NDArray array, Shape shape) {
        return array.reshape(shape);
    }

/**
* Передача метода create, используя только Shape, захватит часть памяти и вернет нам матрицу, не потрудившись
* изменить значение какой-либо из ее записей. Это удивительно эффективно, но мы должны быть осторожны,
* потому что записи могут принимать произвольные значения, в том числе очень большие!
*/

    public static NDArray createNdarray (Shape shape){
        try (NDManager manager =NDManager.newBaseManager()) {
           return manager.create(shape);
        }
    }

/**
 * Как правило, мы хотим, чтобы наши матрицы были инициализированы нулями, единицами, некоторыми другими
 * константами или числами, выбранными случайным образом из определенного распределения.
 * Мы можем создать массив ndarray, представляющий тензор со всеми элементами,
 * равными 0 - manager.zeros(new Shape(2, 3, 4))
 * равными 1 - manager.ones(new Shape(2, 3, 4))
 * Часто мы хотим случайным образом отобрать значения для каждого элемента массива данных
 * из некоторого распределения вероятностей. Например, когда мы создаем массивы, которые будут служить
 * параметрами в нейронной сети, мы обычно инициализируем их значения случайным образом.
 * manager.randomNormal(0f, 1f, new Shape(3, 4), DataType.FLOAT32) - создает массив ndarray с формой ( 3, 4).
 * Каждый из его элементов выбирается случайным образом из стандартного гауссовского (нормального)
 * распределения со средним значением 0 и стандартным отклонением 1
 * Вы также можете просто передать форму, и она будет использовать значения по умолчанию для среднего
 * значения и стандартного отклонения (0 и 1) - manager.randomNormal(new Shape(3, 4))
 * Мы также можем указать точные значения для каждого элемента в желаемом массиве данных,
 * предоставив массив, содержащий числовые значения и желаемую форму
 * - manager.create(new float[]{2, 1, 4, 3, 1, 2, 3, 4, 4, 3, 2, 1}, new Shape(3, 4))
 */
    public static NDArray createInitializedNDarray (int init,Shape shape) throws IOException {
//        try (NDManager manager =NDManager.newBaseManager()) {
//            if (init==0)
//                return manager.zeros(shape);
//            else if (init==1)
//                return manager.ones(shape);
//            else  manager.randomNormal(0f, 1f, shape, DataType.FLOAT32);
//        }
        NDManager manager =NDManager.newBaseManager();
            if (init==0)
                return manager.zeros(shape);
            else if (init==1)
                return manager.ones(shape);
            else return manager.randomNormal(0f, 1f, shape, DataType.FLOAT32);
    }
/**
 * Для функций, которые принимают два массива в качестве входных данных, операции поэлементно применяют некоторый
 * стандартный двоичный оператор к каждой паре соответствующих элементов из двух массивов. Мы можем создать
 * поэлементную функцию из любой функции, которая преобразует скаляр в скаляр.
 * В математической нотации мы бы обозначили такой унарный скалярный оператор (принимающий один входной сигнал)
 * сигнатурой f:R→R. Это просто означает, что функция преобразует любое действительное число (R) в другое.
 * Аналогично, мы обозначаем двоичный скалярный оператор (принимающий два действительных входных сигнала и
 * выдающий один выходной) сигнатурой f:R,R→R. Учитывая любые два вектора u и v одинаковой формы и
 * двоичный оператор f, мы можем получить вектор c=F(u,v),  установив ci∈f(ui,vi) для всех i, где ci,ui и vi - это i-е
 * элементы векторов c,u, и v. Здесь мы создали векторнозначное значение F:Rd,Rd→Rd,преобразовав скалярную функцию
 * в элементарные векторные операции.
 * В DJL все распространенные стандартные арифметические операторы (+, -, *, / и **) преобразованы в поэлементные
 * операции для любых тензоров одинаковой формы произвольной формы. Мы можем вызывать поэлементные операции над любыми
 * двумя тензорами одинаковой формы. В следующем примере мы используем запятые, чтобы составить кортеж из 5 * 5
 * элементов, где каждый элемент является результатом поэлементной операции. Примечание: вам необходимо использовать
 * add, sub, mul, div и pow, поскольку Java не поддерживает перегрузку этих операторов.
 *
 * var x = manager.create(new float[]{1f, 2f, 4f, 8f});
 * var y = manager.create(new float[]{2f, 2f, 2f, 2f});
 * x.add(y);
 *
 * Многие другие операции могут быть применены поэлементно, включая унарные операторы, такие как возведение в степень.
 * x.exp()
 */
public static NDArray calcNdarrayFloat (float[]x,float[]y,String operator){
   if (x.length!=y.length)
       System.out.println("Введены массивы разного размера");
   else {
       NDManager manager = NDManager.newBaseManager();
       if (operator.equals("+"))
           return manager.create(x).add(manager.create(y));
       else if (operator.equals("-"))
           return manager.create(x).sub(manager.create(y));
       else if (operator.equals("*"))
           return manager.create(x).mul(manager.create(y));
       else if (operator.equals("/"))
           return manager.create(x).div(manager.create(y));
       else if (operator.equals("**"))
           return manager.create(x).pow(manager.create(y));
    }
   return null;
  }

    /**
     * Мы также можем объединить несколько ndarray, расположив их вплотную друг к другу, чтобы сформировать более
     * крупный ndarray. Нам просто нужно предоставить список ndarray и указать системе, по какой оси выполнять объединение.
     * В приведенном ниже примере показано, что происходит, когда мы объединяем две матрицы по строкам (ось 0, первый
     * элемент фигуры) и столбцам (ось 1, второй элемент фигуры). Длина оси первого выходного массива- (6) равна сумме
     * длин оси двух входных массивов- (3+3); в то время как длина оси второго выходного массива-  (8) - это сумма длин
     * двух входных массивов по оси 1 ( 4+4).
     * x = manager.arange(12f).reshape(3, 4);
     * y = manager.create(new float[]{2, 1, 4, 3, 1, 2, 3, 4, 4, 3, 2, 1}, new Shape(3, 4));
     * x.concat(y) // default axis = 0
     */

    public static NDArray concatNDarray(NDArray x, NDArray y){
        return x.concat(y);
    }

 /**
  * Иногда мы хотим создать двоичный массив данных с помощью логических инструкций. Возьмем в качестве примера x.eq(y).
  * Для каждой позиции, если x и y равны в этой позиции, соответствующая запись в новом массиве данных принимает значение 1,
  * что означает, что логическое утверждение x.eq(y) (x.lt(y)- меньше или x.gt(y)-больше) истинно в этой позиции;
  * в противном случае эта позиция принимает значение 0
  */
    public static NDArray eqNDArray(NDArray x, NDArray y){
        return x.eq(y);
    }
    /**
     * Суммирование всех элементов в ndarray дает ndarray, содержащий только один элемент.
     * По умолчанию вызов функции для вычисления суммы преобразует массив данных по всем его осям в скаляр.
     * Мы также можем указать оси, по которым массив данных уменьшается с помощью суммирования.
     * Чтобы уменьшить размер строки (ось 0) путем суммирования элементов всех строк,
     * мы указываем new int[] {0} при вызове функции. Поскольку входная матрица уменьшается вдоль оси 0 для генерации
     * выходного вектора, размерность оси 0 входных данных теряется в выходной форме.Указание new int[] {1} уменьшит
     * размер столбца (ось 1) путем суммирования элементов всех столбцов.
     *
     * NDArray ASumAxis0 = A.sum(new int[] {0});
     *
     * Однако иногда бывает полезно сохранить количество осей неизменным при вызове функции для вычисления суммы
     * или среднего значения.
     *
     * NDArray sumA = A.sum(new int[] {1}, true);
     *
     * Например, поскольку sumA по-прежнему сохраняет свои две оси после суммирования каждой строки, мы можем
     * разделить A на sumA с помощью широковещательной передачи.
     *
     * A.div(sumA)
     *
     * Если мы хотим вычислить суммарную сумму элементов A по некоторой оси, скажем, по оси 0 (строка за строкой),
     * мы можем вызвать функцию cumsum. Эта функция не уменьшит входной массив NDArray ни по какой оси.
     *
     * A.cumSum(0);
     *
     */

    public static NDArray sumElementNDArray(NDArray x){
        return x.sum();
    }

    /**
     * При определенных условиях, даже если формы различаются, мы все равно можем выполнять поэлементные операции,
     * вызывая механизм трансляции. Этот механизм работает следующим образом: во-первых, расширьте один или оба массива,
     * скопировав элементы соответствующим образом, чтобы после этого преобразования оба массива имели одинаковую форму.
     * Во-вторых, выполните поэлементные операции с результирующими массивами.
     * В большинстве случаев мы транслируем данные вдоль оси, где массив изначально имеет длину только 1
     * var a = manager.arange(3f).reshape(3, 1);
     * var b = manager.arange(2f).reshape(1, 2);
     * Поскольку a и b равны 3×1 и 1×2 матрицы не совпадают, если мы хотим их добавить. Мы транслируем записи обеих матриц
     * в увеличенный формат 3×2* матрица выглядит следующим образом: для матрицы a она реплицирует столбцы,
     * а для матрицы b - строки, прежде чем суммировать их по элементам  a.add(b)
     */


    /**
     * Индексация и разбиение на части
     * Для индексации и разбиения на части в DJL используется тот же синтаксис, что и в Numpy в Python. Как и в любом
     * другом массиве Python, к элементам в ndarray можно обращаться по индексу. Как и в любом массиве Python, первый
     * элемент имеет индекс 0 и диапазоны указываются так, чтобы они включали первый элемент, но не предшествовали
     * последнему. Как и в стандартных списках Python, мы можем получить доступ к элементам в соответствии с их
     * относительным положением к концу списка, используя отрицательные индексы.
     * Таким образом, [-1] выбирает последний элемент, а [1:3] выбирает второй и третий элементы
     * x.get(":-1")
     */
    public static NDArray getIndex(NDArray x, String indices){
        return x.get(indices);
    }
    /**
     * Помимо чтения, мы также можем записывать элементы матрицы, задавая индексы.
     * x.set(new NDIndex("1, 2"), 9);
     * Если мы хотим присвоить нескольким элементам одинаковое значение, мы просто индексируем их все,
     * а затем присваиваем им значение. Например, [0:2, :] обращается к первой и второй строкам,
     * где : принимает все элементы вдоль оси 1 (столбец). Хотя мы обсуждали индексацию для матриц, очевидно,
     * что это также работает для векторов и тензоров с более чем 2 измерениями.
     * x.set(new NDIndex("0:2, :"), 12);
     */

    /**
     * Выполняемые операции могут привести к выделению новой памяти для размещения результатов. Например, если
     * мы запишем y = x.add(y), мы разыменуем ndarray, на который указывал y, и вместо этого укажем y на вновь
     * выделенную память.
     * Это может быть нежелательно по двум причинам. Во-первых, мы не хотим постоянно тратить время на ненужное
     * выделение памяти. При машинном обучении у нас могут быть сотни мегабайт параметров, и мы можем обновлять их
     * несколько раз в секунду. Как правило, мы хотим выполнить эти обновления на месте. Во-вторых, мы можем указывать
     * на одни и те же параметры из нескольких переменных. Если мы не обновим их на месте, другие ссылки по-прежнему
     * будут указывать на старую ячейку памяти, что позволяет частям нашего кода непреднамеренно ссылаться на устаревшие
     * параметры.
     * К счастью, выполнять операции на месте в DJL несложно. Мы можем присвоить результат операции
     * ранее выделенному массиву, используя встроенные операторы, такие как addi, subi, muli и division
     * var original = manager.zeros(y.getShape());
     * var actual = original.addi(x);
     */

    /**
     * Однако одной из самых фундаментальных операций является скалярное произведение.
      */
     public static NDArray dotNDArray(NDArray x, NDArray y){
         return x.dot(y);
     }
}
