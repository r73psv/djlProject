package com.github.r73pls.djl_Project.deepLearning;

import ai.djl.ndarray.NDArray;
import ai.djl.ndarray.NDManager;
import ai.djl.ndarray.index.NDIndex;
import ai.djl.ndarray.types.Shape;

public class MyPooling {
    /**
     * Максимальное и среднее объединение пулов
     * Подобно сверточным слоям, операторы объединения данных состоят из окна фиксированной формы, которое
     * перемещается по всем областям входных данных в соответствии с шагом, вычисляя один выходной сигнал
     * для каждого местоположения, проходимого окном фиксированной формы (иногда называемым окном объединения данных).
     * Однако, в отличие от вычисления взаимной корреляции входных данных и ядер на сверточном уровне, уровень
     * объединения не содержит параметров (отсутствует фильтр). Вместо этого операторы объединения являются
     * детерминированными, обычно вычисляя либо максимальное, либо среднее значение элементов в окне объединения.
     * Эти операции называются максимальным объединением (для краткости - max pooling) и средним объединением,
     * соответственно. В обоих случаях, как и в случае с оператором взаимной корреляции, мы можем представить
     * окно объединения как начинающееся с верхнего левого края входного массива и скользящее по входному массиву
     * слева направо и сверху вниз. В каждом местоположении, в которое попадает окно объединения, вычисляется
     * максимальное или среднее значение входного подмассива в окне (в зависимости от того, используется ли максимальное
     * или среднее объединение).
     * макс(0,1,3,4)=4, макс (1,2,4,5)=5, макс (3,4,6,7)=7, макс(4,5,7,8)=8
     * В приведенном ниже коде мы реализуем прямое вычисление уровня объединения в функции pool2d.
     * Эта функция аналогична функции corr2d. Однако здесь у нас нет ядра, вычисляющего выходные данные
     * либо как максимальное значение, либо как среднее значение для каждой области во входных данных.
     */
    NDManager manager = NDManager.newBaseManager();

    public NDArray pool2d(NDArray X, Shape poolShape, String mode){

        long poolHeight = poolShape.get(0);
        long poolWidth = poolShape.get(1);

        NDArray Y = manager.zeros(new Shape(X.getShape().get(0) - poolHeight + 1,
                X.getShape().get(1) - poolWidth + 1));
        for(int i=0; i < Y.getShape().get(0); i++){
            for(int j=0; j < Y.getShape().get(1); j++){

                if("max".equals(mode)){
                    Y.set(new NDIndex(i+","+j),
                            X.get(new NDIndex(i + ":" + (i + poolHeight) + ", " + j + ":" + (j + poolWidth))).max());
                }
                else if("avg".equals(mode)){
                    Y.set(new NDIndex(i+","+j),
                            X.get(new NDIndex(i + ":" + (i + poolHeight) + ", " + j + ":" + (j + poolWidth))).mean());
                }

            }
        }

        return Y;
    }
    /*
    Мы можем построить входной массив X, чтобы проверить выходные данные двумерного слоя максимального объединения.
    NDArray X = manager.arange(9f).reshape(3,3);
    pool2d(X, новая форма(2,2), "max");

    экспериментируем со средним объединяющим слоем.
    pool2d(X, новая форма(2,2), "avg");
     */

    /**
     * Как и в случае со сверточными слоями, объединение слоев в пул также может изменить форму вывода.
     * И, как и ранее, мы можем изменить операцию для достижения желаемой формы вывода, заполнив входные данные и
     * отрегулировав шаг. Мы можем продемонстрировать использование отступов и ступеней при объединении слоев
     * в пул с помощью двумерного максимального слоя объединения maxPool2dBlock, входящего в состав модуля пула DJL.
     * Сначала мы создаем входные данные формы (1, 1, 4, 4), где первые два измерения - это пакет и канал
     * X = manager.arange(16f).reshape(1, 1, 4, 4);
     * Ниже мы используем окно объединения фигур (3, 3) и форму шага (3, 3)
     *
     * // определяющий блок, задающий ядро и шаг
     * Block block = Pool.maxPool2dBlock(new Shape(3, 3), new Shape(3, 3));
     * block.initialize(manager, DataType.FLOAT32,new Shape(1,1,4,4));
     *
     * ParameterStore parameterStore = new ParameterStore(manager, false);
     * // Поскольку в объединяющем слое нет параметров модели, нам не нужно
     * // для вызова функции инициализации параметра
     * block.forward(parameterStore, new NDList(X), true).singletonOrThrow();
     *
     * Шаг и отступы можно задать вручную.
     *
     * // переопределяем формы блоков для формы ядра, формы шага и формы площадки
     * block = Pool.maxPool2dBlock(new Shape(3,3), new Shape(2,2), new Shape(1,1));
     * // метод переадресации блоков
     * block.forward(parameterStore, new NDList(X), true).singletonOrThrow();
     *
     * Конечно, мы можем указать произвольное прямоугольное окно объединения и указать отступы для высоты
     * и ширины соответственно.
     *
     * // переопределяем формы блоков для формы ядра, формы шага и формы площадки
     * block = Pool.maxPool2dBlock(new Shape(2,3), new Shape(2,3), new Shape(1,2));
     * block.forward(parameterStore, new NDList(X), true).singletonOrThrow();
     */

    /**
     * Множество каналов
     * При обработке многоканальных входных данных уровень объединения объединяет каждый входной канал отдельно,
     * а не добавляет входные данные каждого канала по каналам, как в сверточном уровне.
     * Это означает, что количество выходных каналов для объединяющего слоя совпадает с количеством входных каналов.
     * Ниже мы объединим массивы X и X+1 в измерении канала, чтобы построить вход с 2 каналами.
     *
     * X = X.concat(X.add(1), 1);
     * Как мы видим, после объединения количество выходных каналов по-прежнему равно 2.
     *
     * block = Pool.maxPool2dBlock(new Shape(3,3), new Shape(2,2), new Shape(1,1));
     * block.forward(parameterStore, new NDList(X), true).singletonOrThrow();
     */
}
